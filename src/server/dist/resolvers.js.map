{"version":3,"sources":["../src/resolvers.js"],"names":["jwt","require","createToken","user","secret","expiresIn","username","email","sign","resolvers","Query","getAllRecipes","root","args","RecipeModel","allRecipes","find","getCurrentUser","currentUser","UserModel","populate","path","model","Mutation","addRecipe","context","name","description","category","instructions","newRecipe","save","signupUser","password","findOne","Error","newUser","token","process","env","SECRET","signinUser","isValidPassword","bcrypt","compare"],"mappings":";;;;;;AACA;;;;;;AADA,MAAMA,MAAMC,QAAQ,cAAR,CAAZ;;;AAGA,MAAMC,cAAc,CAACC,IAAD,EAAOC,MAAP,EAAeC,SAAf,KAA6B;AAC9C,SAAM,EAAEC,QAAF,EAAYC,KAAZ,KAAsBJ,IAA5B;AACA,UAAOH,IAAIQ,IAAJ,CAAS,EAAEF,QAAF,EAAYC,KAAZ,EAAT,EAA8BH,MAA9B,EAAsC,EAAEC,SAAF,EAAtC,CAAP;AACF,CAHD;;AAKA,MAAMI,YAAY;AACfC,UAAO;AACJC,qBAAe,OAAOC,IAAP,EAAaC,IAAb,EAAmB,EAAEC,WAAF,EAAnB,KAAuC;AACnD,eAAMC,aAAa,MAAMD,YAAYE,IAAZ,EAAzB;AACA,gBAAOD,UAAP;AACF,OAJG;;AAMJE,sBAAgB,OAAOL,IAAP,EAAaC,IAAb,EAAmB,EAAEK,WAAF,EAAeC,SAAf,EAAnB,KAAkD;AAC/D,aAAI,CAACD,WAAL,EAAkB;AACf,mBAAO,IAAP;AACF;AACD,eAAMf,OAAO,MAAMgB,UAAUH,IAAV,CAAe,EAAEV,UAAUY,YAAYZ,QAAxB,EAAf,EAChBc,QADgB,CACP;AACPC,kBAAM,WADC;AAEPC,mBAAO;AAFA,UADO,CAAnB;;AAMA,gBAAOnB,IAAP;AAGF;AAnBG,IADQ;AAsBfoB,aAAU;AACPC,iBAAW,OAAOZ,IAAP,EAAaC,IAAb,EAAmBY,OAAnB,KAA+B;AACvC,eAAM,EAAEC,IAAF,EAAQC,WAAR,EAAqBC,QAArB,EAA+BC,YAA/B,EAA6CvB,QAA7C,KAA0DO,IAAhE;AACA,eAAM,EAAEC,WAAF,KAAkBW,OAAxB;AACA,eAAMK,YAAY,MAAM,IAAIhB,WAAJ,CAAgB;AACrCY,gBADqC;AAErCC,uBAFqC;AAGrCC,oBAHqC;AAIrCC,wBAJqC;AAKrCvB;AALqC,UAAhB,EAMrByB,IANqB,EAAxB;AAOA,gBAAOD,SAAP;AACF,OAZM;;AAcPE,kBAAY,OAAOpB,IAAP,EAAa,EAAEN,QAAF,EAAYC,KAAZ,EAAmB0B,QAAnB,EAAb,EAA4C,EAAEd,SAAF,EAA5C,KAA8D;AACvE,eAAMhB,OAAO,MAAMgB,UAAUe,OAAV,CAAkB,EAAE5B,QAAF,EAAlB,CAAnB;AACA,aAAIH,IAAJ,EAAU;AACP,kBAAM,IAAIgC,KAAJ,CAAU,sBAAV,CAAN;AACF;;AAED,eAAMC,UAAU,MAAM,IAAIjB,SAAJ,CAAc;AACjCb,oBADiC;AAEjCC,iBAFiC;AAGjC0B;AAHiC,UAAd,EAInBF,IAJmB,EAAtB;;AAMA,gBAAO,EAAEM,OAAOnC,YAAYkC,OAAZ,EAAqBE,QAAQC,GAAR,CAAYC,MAAjC,EAAyC,KAAzC,CAAT,EAAP;AACF,OA3BM;;AA6BPC,kBAAY,OAAO7B,IAAP,EAAa,EAAEN,QAAF,EAAY2B,QAAZ,EAAb,EAAqC,EAAEd,SAAF,EAArC,KAAuD;AAChE,eAAMhB,OAAO,MAAMgB,UAAUe,OAAV,CAAkB,EAAE5B,QAAF,EAAlB,CAAnB;AACA,aAAI,CAACH,IAAL,EAAW;AACR,kBAAM,IAAIgC,KAAJ,CAAU,gBAAV,CAAN;AACF;;AAED,eAAMO,kBAAkB,MAAMC,mBAAOC,OAAP,CAAeX,QAAf,EAAyB9B,KAAK8B,QAA9B,CAA9B;AACA,aAAI,CAACS,eAAL,EAAsB;AACnB,kBAAM,IAAIP,KAAJ,CAAU,kBAAV,CAAN;AACF;;AAED,gBAAO,EAAEE,OAAOnC,YAAYC,IAAZ,EAAkBmC,QAAQC,GAAR,CAAYC,MAA9B,EAAsC,KAAtC,CAAT,EAAP;AACF;AAzCM;AAtBK,CAAlB;;kBAmEe/B,S","file":"resolvers.js","sourcesContent":["const jwt = require('jsonwebtoken');\r\nimport bcrypt from 'bcryptjs';\r\n\r\nconst createToken = (user, secret, expiresIn) => {\r\n   const { username, email } = user;\r\n   return jwt.sign({ username, email }, secret, { expiresIn });\r\n};\r\n\r\nconst resolvers = {\r\n   Query: {\r\n      getAllRecipes: async (root, args, { RecipeModel }) => {\r\n         const allRecipes = await RecipeModel.find();\r\n         return allRecipes;\r\n      },\r\n\r\n      getCurrentUser: async (root, args, { currentUser, UserModel }) => {\r\n         if (!currentUser) {\r\n            return null;\r\n         }\r\n         const user = await UserModel.find({ username: currentUser.username })\r\n           .populate({\r\n              path: 'favorites',\r\n              model: 'Recipe'\r\n           });\r\n\r\n         return user;\r\n\r\n\r\n      }\r\n   },\r\n   Mutation: {\r\n      addRecipe: async (root, args, context) => {\r\n         const { name, description, category, instructions, username } = args;\r\n         const { RecipeModel } = context;\r\n         const newRecipe = await new RecipeModel({\r\n            name,\r\n            description,\r\n            category,\r\n            instructions,\r\n            username\r\n         }).save();\r\n         return newRecipe;\r\n      },\r\n\r\n      signupUser: async (root, { username, email, password }, { UserModel }) => {\r\n         const user = await UserModel.findOne({ username });\r\n         if (user) {\r\n            throw new Error('User already existed');\r\n         }\r\n\r\n         const newUser = await new UserModel({\r\n            username,\r\n            email,\r\n            password\r\n         }).save();\r\n\r\n         return { token: createToken(newUser, process.env.SECRET, '1hr') };\r\n      },\r\n\r\n      signinUser: async (root, { username, password }, { UserModel }) => {\r\n         const user = await UserModel.findOne({ username });\r\n         if (!user) {\r\n            throw new Error('User not found');\r\n         }\r\n\r\n         const isValidPassword = await bcrypt.compare(password, user.password);\r\n         if (!isValidPassword) {\r\n            throw new Error('Invalid password');\r\n         }\r\n\r\n         return { token: createToken(user, process.env.SECRET, '1hr') };\r\n      }\r\n   }\r\n};\r\n\r\nexport default resolvers;\r\n"]}